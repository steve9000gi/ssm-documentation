The System Support Map Processing Sequence: An Example
2017/07/19

For this example we assume the existence of a set of n system support maps (SSMs), x1.json, x2.json,
..., xn.json: files output by one of
http://syssci.renci.org/ssm/,
http://syssci.renci.org/ssm_beh/,
http://syssci.renci.org/ssm-wizard-d/,
http://syssci.renci.org/ssm-wizard/?module=CaregiversCYSHCN,
http://syssci.renci.org/ssm-wizard/?module=TitleVWorkforce,
http://syssci.renci.org/ssm-wizard-mental-health-in-schools/,
or their ilk.

A number of programs are used to create and process this set of SSMs. Further information for each,
including source code, can be found at the following locations online:
1. Source code for the various ssm websites: https://github.com/steve9000gi/ssm
2. blm.R: https://github.com/steve9000gi/binary-link-matrix
3. The sort website: at http://syssci.renci.org/sort/, source at https://github.com/steve9000gi/sort
4. text2JSON.py: https://github.com/steve9000gi/text2JSON/blob/master/text2JSON.py
5. cat_sorted_json.py: https://github.com/steve9000gi/text2JSON/blob/master/cat_sorted_json.py
6. AddCodesToBLM.R: https://github.com/steve9000gi/AddCodesToBLM
7. create_code_matrices.py: https://github.com/steve9000gi/create_code_matrices/blob/master/create_code_matrices.py
8. create_code_presence_matrix.py: https://github.com/steve9000gi/create_code_matrices/blob/master/create_code_presence_matrix.py

There are two different .json file formats used throughout this processing sequence:
1. The SSM format, generated by any of the list of ssm websites listed above, required for input
into blm.R;
2. The Sort format, generated as (some of) the output from blm.R, optionally as input to the sort
website, required for reopening a partially sorted file in sort, output from the sort website, and
required as input into AddCodesToBLM.R. This format is described in https://github.com/steve9000gi/sort/blob/master/File_Formats_for_the_Sort_Segment_of_the_System_Support_Mapping_Processing_Sequence.docx.

The various steps in the sequence are primarily effected by calling scripts from a Unix/Linux
command line. This example was executed and verified in a terminal in OSX version 10.11.6.

# Step 1: Create the directory structure at /path/to/:
$ cd /path/to/
$ mkdir project-x
$ cd project-x
$ mkdir ssm blm cblm sorted cm cpm
$ ls ../project-x
blm	cblm	cm	sorted	ssm	cpm

# Copy the project-x system support maps into /path/to/project-x/ssm:
$ cp /path/to/ssms-project-x/*.json ssm
$ cd ..; ls -R project-x; cd project-x
blm	cblm	cm	sorted	ssm	cpm

project-x/blm:

project-x/cblm:

project-x/cm:

project-x/cpm:

project-x/sorted:

project-x/ssm:
x1.json	x2.json...xn.json

# Step 2: Create Binary Link Matrices (BLMs: also known as adjacency matrices) and the node classes
files from the SSMs:
$ Rscript blm.R /path/to/project-x/ssm /path/to/project-x/blm

# Above, the first argument is the path to the directory of SSMs used as input. The second 
argument is the directory into which the corresponding BLMs will be output.

# Let's see what we created:
$ ls blm
NEEDS.json		TEXTS.json		x1-BLM.csv
RESOURCES.json		WISHES.json		x2-BLM.csv
RESPONSIBILITIES.json	aggregated.json		...
ROLES.json		aggregated.txt          xn-BLM.csv

# The .json files are all in Sort format. Those named by ring (ROLES.json, etc.) each represent all
the text for all the nodes in all the SSMs in the input directory belonging to the corresponding
ring. For example, ROLES.json will have the text for all the Role nodes; aggregated.json combines
the contents for all the ring-named files into a single file. Equivalently, aggregated.txt contains
the same info except in text format. This is made available because a text list is much easier for
hand-editing than .json, should this be desired. The sort website can use any of these files as
input.

# The files ending in "-BLM.csv" contain Binary Link (adjacency) Matrices (BLMs) derived from the
correspondingly named SSMs. These will be used later, after sorting is complete.

# Step 3: Sorting:

# Sort option 1: drag and drop aggregated.json or aggregated.txt into the sort website. This allows
you to sort all the data for all the rings at once. This is most conventient from a workflow 
viewpoint, except in real world situations there are usually too many items to be sorted for this
to be practicable. Also, thus far no one has wanted to sort items from different rings into the
same code category. In any case, output (from sort) a single .json file (name it what you wish; 
for this example let's call it sorted.json), whereever you like, but to reduce confusion 
/path/to/project-x/sorted/sorted.json might work well.

# Sort option 2: drag and drop the lists a ring at a time, sort and output as separate .json files.
This requires concatenating the output into a single file for AddCodesToBLM.R. Assuming all the
individual sorted .json files output from sort are placed in the directory project-x/sorted, thus:
$ ls /path/to/project-x/sorted
needsSorted.json	resourcesSorted.json	rolesSorted.json
respSorted.json		textsSorted.json    	wishesSorted.json

# ...you'll need to perform the following:
$ cat_sorted_json.py /path/to/project-x/sorted

# The preceding will output a file named /path/to/project-x/sorted/cattedJSON.json.

# Sort option 3: drag and drop the lists a ring at a time, as in Sort option #2, but for this option
 you'll sort and output as separate text (.txt) files. This also requires concatenating the output
into a single file for AddCodesToBLM.R, but in this case we'll be concatenating .txt files
and then converting that result file into .json format. Assuming all the individual sorted .txt
files output from sort are placed in the directory project-x/sorted, thus...
$ ls /path/to/project-x/sorted
needsSorted.txt        resourcesSorted.txt    rolesSorted.txt
respSorted.txt         textsSorted.txt        wishesSorted.txt

# ...you'll need to perform the following:
$ cd /path/to/project-x/sorted # Change directory to where all the sorted text files are.
$ cat *.txt >> cattedText.txt  # Concatentate them into a single text file (call it what you wish).
$ text2JSON.py /path/to/project-x/sorted/cattedText.txt
text2JSON.py: /path/to/project-x/sorted/cattedText.txt -> /path/to/project-x/sorted/cattedText.json
# The single argument for text2JSON.py is the path to the text file you wish to convert to .json.
The output file has the identical path except its extension is .json.

# Step 4: Add Codes to BLMs:

# The output from sort is a list of codes with the node text items that belong to each code
category.  The next script inserts the appropriate code for each node text item into the BLM file
that corresponds to the SSM from which that text item originated. The result is a new Coded Binary
Link Matrix (CBLM) file for each map:
$ Rscript AddCodesToBLM.R /path/to/project-x/sorted/<sorted>.json /path/to/project-x/blm
/path/to/project-x/cblm
Number of BLM input files: <n>
1: x1-BLM.csv -> /path/to/project-x/cblm/x1-CBLM.csv
2: x2-BLM.csv -> /path/to/project-x/cblm/x2-CBLM.csv
...
n: xn-BLM.csv -> /path/to/project-x/cblm/xn-CBLM.csv

# Above, the first argument is the path to the <sorted>.json file. For all three Sort options we
put this file in /path/to/project-x/sorted. For Sort option 1 <sorted> = "sorted"; for Sort
option 2 <sorted> = "cattedJSON"; for Sort option 3 <sorted> = "cattedText"; you may name these 
files as you wish: we use these names to distnguish between the three different ways of getting the
files. The second argument is the path to the directory where we put the BLM files with blm.R.  The
third argument is the directory where we're going to put the CBLM files.

# Note that all the CBLM files have the same names as the BLM files (and the SSM files) from which
they were derived, except for the extensions. So, if an SSM file is named <fname>.json, then the BLM
file derived from it will be named <fname>-BLM.csv, and the derived CBLM file will be named
<fname>-CBLM.csv.

# Step 5: Create Code Matrices:

# Use the directory of CBLMs that you generated with AddCodesToBLM.R to create a set of Code
Matrices (CMs) -- adjacency matrices -- showing, for each of the original System Support Maps, how
the codes associated with the node texts in that SSM are associated with each other. There will be
one CM for each of the original SSMs in the set;  each CM's width and height will be equal to the
total number of codes. The codes for all the SSMs in this set are used as labels for the rows and
columns of each CM. In addition, a file sum-CM.csv will be created that represents the sum of all
the individual CMs. For our example project-x the call would be as follows:

$ create_code_matrices.py /path/to/project-x/cblm /path/to/project-x/cm
0: /path/to/project-x/cblm/x1-CBLM.csv -> /path/to/project-x/cm/x1-CM.csv
1: /path/to/project-x/cblm/x2-CBLM.csv -> /path/to/project-x/cm/x2-CM.csv
...
n: /path/to/project-x/cblm/xn-CBLM.csv -> /path/to/project-x/cm/xn-CM.csv

# Above, the first argument is the path to the CBLM directory used as input. The second argument is
the path to the CM directory where the output files will be written.

# Step 6: Create Code Presence Matrix (CPM):

# Here we generate a matrix where the row names are the names of all the System Support Map files in
a project (minus their extensions), and the column names are all the codes for that project, and
each element is the number of times the code used to name the column in which that element appears
in the SSM file that names the element's row.

$ create_code_presence_matrix.py /path/to/project-x/cblm /path/to/project-x/cpm
Done.
$ 

# Above, the first argument is the path to a directory of CBLMs used as input. The second argument
is the path to a directory to be used as the location for placing the output Code Presence Matix.
